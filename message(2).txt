
local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/HeavenlyScripts/1nig1htmare1234-OrionLib-with-Black-CheckMarks/main/Orion.lua"))() -- meine ui

local Window = OrionLib:MakeWindow({
    Name = "‚îÇTrixo v13 ‚îÇ„ÄÑEmergency Hamburg",
    HidePremium = false,
    SaveConfig = true,
    ConfigFolder = "test",
    IntroEnabled = true,
    IntroText = "Trixo v13",
})

Tab1 = Window:MakeTab({
	Name = "Aimbot | üî¥",
	PremiumOnly = false
})

local Section = Tab1:AddSection({
	Name = "Aimbot-settings"
})



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local aimbotEnabled = false
local triggerbotEnabled = false
local aimbotFOV = 100

-- Funktionen
function getClosestTarget()
	local closest, shortest = nil, aimbotFOV
	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
			local screenPos, onScreen = Camera:WorldToViewportPoint(plr.Character.Head.Position)
			if onScreen then
				local dist = (Vector2.new(UIS:GetMouseLocation().X, UIS:GetMouseLocation().Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
				if dist < shortest then
					closest = plr
					shortest = dist
				end
			end
		end
	end
	return closest
end

RunService.RenderStepped:Connect(function()
	if aimbotEnabled and UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
		local target = getClosestTarget()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			Camera.CFrame = CFrame.new(Camera.CFrame.Position, target.Character.Head.Position)
		end
	end

	if triggerbotEnabled and UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
		local mouse = LocalPlayer:GetMouse()
		local target = mouse.Target
		if target and target.Parent and target.Parent:FindFirstChild("Humanoid") then
			mouse1click() -- Muss vom Exploit unterst√ºtzt werden!
		end
	end
end)

-- Rayfield UI
Tab1:AddToggle({
	Name = "üî¥ Aimbot (Right mouse button)",
	CurrentValue = false,
	Flag = "AimbotToggle",
	Callback = function(v) aimbotEnabled = v end,
})


Tab1:AddSlider({
	Name = "üî¥ Aimbot-St√§rke",
	Min = 20,
	Max = 300,
	Default = 10,
	Color = Color3.fromRGB(255,255,255),
	Increment = 10,
	ValueName = "St√§rke",
	Callback = function(v) aimbotFOV = v end,   
})


local showFOV = false
local fovRadius = 100
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 2
fovCircle.NumSides = 64
fovCircle.Color = Color3.fromRGB(0, 255, 255)
fovCircle.Transparency = 0.5
fovCircle.Filled = false

Tab1:AddToggle({
	Name = "üî¥ Show FOV Circle",
	CurrentValue = false,
	Callback = function(val)
		showFOV = val
		fovCircle.Visible = val
	end,
})


Tab1:AddSlider({
	Name = "üî¥ FOV-Radius",
	Min = 50,
	Max = 300,
	Default = 10,
	Color = Color3.fromRGB(255,255,255),
	Increment = 10,
	ValueName = "FOV",
	Callback = function(v)
		fovRadius = v
		fovCircle.Radius = v
	end,  
})


RunService.RenderStepped:Connect(function()
	if showFOV then
		local mouse = UIS:GetMouseLocation()
		fovCircle.Position = Vector2.new(mouse.X, mouse.Y + 36) -- +36 f√ºr GUI-Versatz
	end
end)


Tab1:AddToggle({
	Name = "üî¥ Triggerbot",
	CurrentValue = false,
	Flag = "TriggerToggle",
	Callback = function(v) triggerbotEnabled = v end,
})

-- FOV-Kreis f√ºr Aimbot
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 2
fovCircle.NumSides = 64
fovCircle.Color = Color3.fromRGB(0, 255, 255)
fovCircle.Transparency = 0.5
fovCircle.Filled = false

-- üì¶ Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ‚öôÔ∏è Einstellungen
local aimbotEnabled = false
local aimbotMenuVisible = false -- Men√º sichtbar oder nicht
local aimbotFOV = 150
local smoothness = 0.15

-- üîç Ziel
local lockedTarget = nil
local allTargets = {}

-- üì± GUI erstellen
local ScreenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
ScreenGui.ResetOnSpawn = false

-- Aim-Button
local AimButton = Instance.new("TextButton", ScreenGui)
AimButton.Size = UDim2.new(0, 80, 0, 80)
AimButton.Position = UDim2.new(0.5, 0, 0.8, 0)
AimButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
AimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AimButton.Text = "üî¥"
AimButton.TextScaled = true
AimButton.BorderSizePixel = 0
AimButton.AnchorPoint = Vector2.new(0.5, 0.5)
AimButton.Active = true
AimButton.Draggable = true
AimButton.Visible = false

-- FOV-Kreis
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Color = Color3.fromRGB(0, 128, 0)
FOVCircle.Thickness = 2
FOVCircle.NumSides = 64
FOVCircle.Radius = aimbotFOV
FOVCircle.Filled = false

-- üîç N√§chsten Spieler finden
local function getClosestTarget()
	local closest, shortest = nil, aimbotFOV
	allTargets = {}
	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid") then
			if plr.Character.Humanoid.Health > 0 then
				table.insert(allTargets, plr)
				local head = plr.Character.Head
				local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
				if onScreen then
					local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
					local dist = (screenCenter - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
					if dist < shortest then
						closest = plr
						shortest = dist
					end
				end
			end
		end
	end
	return closest
end

-- üéØ Kamera nachziehen
RunService.RenderStepped:Connect(function()
	if aimbotEnabled then
		local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
		FOVCircle.Visible = true
		FOVCircle.Position = screenCenter

		if not lockedTarget or not lockedTarget.Character or not lockedTarget.Character:FindFirstChild("Humanoid") or lockedTarget.Character.Humanoid.Health <= 0 then
			lockedTarget = getClosestTarget()
		else
			local head = lockedTarget.Character.Head
			local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
			local dist = (screenCenter - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
			if dist > aimbotFOV then
				lockedTarget = getClosestTarget()
			end
		end

		if lockedTarget and lockedTarget.Character and lockedTarget.Character:FindFirstChild("Head") then
			local head = lockedTarget.Character.Head
			local targetCF = CFrame.new(Camera.CFrame.Position, head.Position)
			Camera.CFrame = Camera.CFrame:Lerp(targetCF, smoothness)
		end
	else
		FOVCircle.Visible = false
	end
end)

-- üîò Aim-Button ‚Üí Aimbot toggeln
AimButton.MouseButton1Click:Connect(function()
	aimbotEnabled = not aimbotEnabled
	if aimbotEnabled then
		lockedTarget = getClosestTarget()
		AimButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	else
		lockedTarget = nil
		AimButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	end
end)

Tab1:AddToggle({
	Name = "üî¥ Mobile Aimbot Menu",
	StartingState = false,
	Callback = function(state)
		aimbotMenuVisible = state
		AimButton.Visible = state
	end
})
local Section = Tab1:AddSection({
	Name = "üî¥ Weapon Settings"
})

local aimFOVEnabled = false
Tab1:AddToggle({
    Name = "üî¥ Aim FOV",
    CurrentValue = false,
    Flag = "AimFOV",
    Callback = function(v)
        aimFOVEnabled = v

        if v then
            OrionLib:MakeNotification({ Title = "Aim FOV", Content = "Aktiviert!", Duration = 2 })
            task.spawn(function()
                while aimFOVEnabled do
                    local tool = plr.Character and plr.Character:FindFirstChildOfClass("Tool")
                    if tool then
                        tool:SetAttribute("AimFieldOfView", 70)
                    end
                    task.wait(0.1)
                end
            end)
        else
            OrionLib:MakeNotification({ Title = "Aim FOV", Content = "Deaktiviert!", Duration = 2 })
        end
    end
})


-- üß† Auto Reload Logik
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")

local autoRefillEnabled = false

-- Liste deiner Waffen
local trackedWeapons = {
	"G36",
	"Glock 17",
	"MP5",
	"M4 Carabine",
	"Sniper",
	"M58B Shotgun"
}

-- üîÑ Auto-Check Loop
task.spawn(function()
	while true do
		if autoRefillEnabled then
			pcall(function()
				local char = LocalPlayer.Character
				if char then
					for _, weaponName in ipairs(trackedWeapons) do
						local weapon = char:FindFirstChild(weaponName) or workspace:FindFirstChild(weaponName)
						if weapon then
							local magSize = weapon:GetAttribute("MagCurrentSize") 
								or weapon:GetAttribute("Ammo") 
								or weapon:GetAttribute("Clip")
								or (weapon:FindFirstChild("Ammo") and weapon.Ammo.Value)

							if magSize and magSize == 0 then
								VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
								task.wait(0.1)
								VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
								task.wait(1)
							end
						end
					end
				end
			end)
		end
		task.wait(0.5)
	end
end)

-- ‚úÖ Rayfield Toggle
Tab1:AddToggle({
	Name = "üî¥ Auto-Reload",
	CurrentValue = false,
	Flag = "AutoReload",
	Callback = function(Value)
		autoRefillEnabled = Value
	end
})

-- üéØ Toggle Crosshair Feature
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local crosshairActive = false

Tab1:AddToggle({
	Name = "üî¥ Small-Crosshair",
	CurrentValue = false,
	Flag = "SmallCrosshair",
	Callback = function(Value)
		crosshairActive = Value

		if crosshairActive then
			-- ‚è≥ Aktiviert: Pr√ºfe Tool und passe Attribut an
			task.spawn(function()
				while crosshairActive do
					local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
					if tool then
						tool:SetAttribute("CrosshairSize", 1)
					end
					task.wait(0.1)
				end
			end)
		else
			-- ‚ùå Deaktiviert: Kein weiteres Verhalten n√∂tig
		end
	end
})

-- ‚ö° Rapid Fire Toggle
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local rapidFireEnabled = false

Tab1:AddToggle({
	Name = "üî¥ Rapid-Fire",
	CurrentValue = false,
	Flag = "RapidFireToggle",
	Callback = function(Value)
		rapidFireEnabled = Value

		if rapidFireEnabled then
			-- Aktiviere Rapid Fire durch st√§ndiges Setzen der Werte
			task.spawn(function()
				while rapidFireEnabled do
					local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
					if Tool then
						Tool:SetAttribute("ShootDelay", 0)
						Tool:SetAttribute("Automatic", true)
					end
					task.wait(0.1)
				end
			end)
		end
	end
})

-- üéØ Toggle f√ºr No Recoil
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local noRecoilEnabled = false

Tab1:AddToggle({
	Name = "üî¥ No-Recoil",
	CurrentValue = false,
	Flag = "NoRecoilToggle",
	Callback = function(Value)
		noRecoilEnabled = Value

		if noRecoilEnabled then
			task.spawn(function()
				while noRecoilEnabled do
					local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
					if Tool then
						Tool:SetAttribute("Recoil", 0)
						Tool:SetAttribute("Instability", 0)
					end
					task.wait(0.1)
				end
			end)
		end
	end
})

Tab2 = Window:MakeTab({
	Name = "Silent-aim | üî´",
	PremiumOnly = false
})


Tab2:AddSection({
	Name = "Silent-Aim-Settings"
})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- remote safe resolve (timeout)
local function resolveRemote()
	local ok, folder = pcall(function() return ReplicatedStorage:WaitForChild("MW5", 5) end)
	if not ok or not folder then return nil end
	local ok2, remote = pcall(function() return folder:WaitForChild("7ac19887-c231-417a-a139-c150778da985", 5) end)
	if not ok2 or not remote then return nil end
	return remote
end

local GUN_REMOTE = resolveRemote()
if not GUN_REMOTE then
	-- notify but we continue; the toggle will check remote before firing
	warn("asdasdasdasd")
end

-- Config (defaults)
local FOV_RADIUS = 185
local PREDICTION = 0.33
local SHOOT_DELAY = 0.022
local SILENT_AIM = false

-- Teams: true = hittet, false = ignoriert!
local allowedTeams = {
	["Criminals"] = true,
	["Wanted"] = true,
	["Police"] = true,    -- set true if you want police targeted
	["Fire Department"] = false,
	["Busfahrer"] = false,
	["Civil"] = false,
	["LKW Fahrer"] = false,
}


Tab2:AddSlider({
	Name = "üü§ Silent Aim FOV",
	Min = 50,
	Max = 300,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "FOV",
	CurrentValue = FOV_RADIUS,
	Callback = function(val) FOV_RADIUS = val end   
})


Tab2:AddSlider({
	Name = "üü§ Prediction Power",
	Min = 0.10,
	Max = 0.45,
	Default = 0.001,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.001,
	ValueName = "",
	CurrentValue = PREDICTION,
	Callback = function(val) PREDICTION = val end    
})


Tab2:AddSlider({
	Name = "üü§ Shoot Speed (s)",
	Min = 0.012,
	Max = 0.10,
	Default = 0.001,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.001,
	ValueName = "s",
	CurrentValue = SHOOT_DELAY,
	Callback = function(val) SHOOT_DELAY = val end   
})

Tab2:AddToggle({
	Name = "üü§ Silent Aim",
	CurrentValue = false,
	Flag = "SilentAim",
	Callback = function(value)
		SILENT_AIM = value
		if value then
			-- try resolve remote again when enabling
			if not GUN_REMOTE then
				GUN_REMOTE = resolveRemote()
				if not GUN_REMOTE then
					OrionLib:MakeNotification({Title = "Silent Aim", Content = "Gun remote not found. Aborting.", Duration = 4})
					SILENT_AIM = false
					toggle:Set(false)
					return
				end
			end
			OrionLib:MakeNotification({Title = "Silent Aim", Content = "Enabled", Duration = 2})
			spawn(function()
				-- run loop in background
				local function inAllowedTeam(plr)
					if not plr.Team then return false end
					local tname = tostring(plr.Team)
					if allowedTeams[tname] ~= nil then
						return allowedTeams[tname]
					end
					return false
				end

				while SILENT_AIM do
					-- ensure character present
					local char = LocalPlayer.Character
					local myHRP = char and char:FindFirstChild("HumanoidRootPart")
					local gun = char and char:FindFirstChildOfClass("Tool")
					-- if no gun, wait
					if not myHRP or not gun then
						task.wait(0.15)
						continue
					end

					-- find target
					local closest, minDist = nil, FOV_RADIUS
					for _, plr in ipairs(Players:GetPlayers()) do
						if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
							local hum = plr.Character:FindFirstChildOfClass("Humanoid")
							local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
							if hum and hum.Health > 0 and hrp then
								local teamOK = inAllowedTeam(plr) or hrp:GetAttribute("IsWanted")
								if teamOK then
									local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
									local screenPos = Vector2.new(pos.X, pos.Y)
									local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
									local dist = (screenPos - center).Magnitude
									if onScreen and dist < minDist then
										closest = plr
										minDist = dist
									end
								end
							end
						end
					end

					if closest and GUN_REMOTE then
						-- compute predicted position and direction
						local targetHRP = closest.Character and closest.Character:FindFirstChild("HumanoidRootPart")
						if targetHRP and targetHRP:IsA("BasePart") and myHRP and myHRP:IsA("BasePart") then
							local predPos = targetHRP.Position + (targetHRP.Velocity * PREDICTION)
							local dir = (predPos - myHRP.Position)
							if dir.Magnitude > 0 then
								dir = dir.Unit
								-- call remote safely
								pcall(function()
									if GUN_REMOTE and GUN_REMOTE.FireServer then
										GUN_REMOTE:FireServer(gun, predPos, dir)
									end
								end)
							end
						end
						task.wait(SHOOT_DELAY)
					else
						task.wait(0.06)
					end
				end
			end)
		else
			OrionLib:MakeNotification({Title = "Silent Aim", Content = "Disabled", Duration = 2})
		end
	end
})

-- Drawing FOV circle (optional)
local hasDrawing, Drawing = pcall(function() return Drawing end)
local circle
if hasDrawing and Drawing then
	circle = Drawing.new("Circle")
	circle.Color = Color3.fromRGB(255,190,50)
	circle.Radius = FOV_RADIUS
	circle.Thickness = 2
	circle.Filled = false
	circle.Transparency = 0.78
	circle.Visible = false

	RunService.RenderStepped:Connect(function()
		if circle then
			circle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
			circle.Radius = FOV_RADIUS
			circle.Visible = SILENT_AIM
		end
	end)
end

-- Clean up on unload (optional)
local function cleanup()
	SILENT_AIM = false
	if circle then
		pcall(function() circle:Remove() end)
	end
end

Tab3 = Window:MakeTab({
	Name = "ESP | üëÅÔ∏è",
	PremiumOnly = false
})

Tab3:AddSection({
	Name = "Visuals-Settings"
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local plr = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local state = {
    espEnabled = false,
    showNames = true,
    showTeams = true,
    showDistance = true,
    showHealth = true,
    showEquipped = true,
    showWanted = true,
    espObjects = {},
    espDistance = 1000
}

-- üü¶ Teamfarbe bestimmen
local function teamColorForTeam(team)
    if not team then return Color3.fromRGB(200,200,200) end
    local tn = tostring(team.Name):lower()
    if tn:find("police") then
        return Color3.fromRGB(80,160,255)
    elseif tn:find("fire") then
        return Color3.fromRGB(255,80,80)
    elseif tn:find("hospital") or tn:find("medic") then
        return Color3.fromRGB(120,255,140)
    else
        return Color3.fromRGB(200,200,200)
    end
end

-- üß± ESP erstellen
local function createESPForPlayer(other)
    if not other.Character then return end
    if state.espObjects[other.UserId] then return end

    local hrp = other.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_" .. other.Name
    billboard.Adornee = hrp
    billboard.Size = UDim2.new(0,160,0,100)
    billboard.StudsOffset = Vector3.new(0,3.5,0)
    billboard.AlwaysOnTop = true
    billboard.Parent = other.Character

    local function newLabel(yOffset, color)
        local lbl = Instance.new("TextLabel", billboard)
        lbl.Size = UDim2.new(1,0,0,18)
        lbl.Position = UDim2.new(0,0,0,yOffset)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.GothamBold
        lbl.TextSize = 13
        lbl.TextStrokeTransparency = 0.6
        lbl.TextColor3 = color or Color3.new(1,1,1)
        return lbl
    end

    local nameLbl = newLabel(0)
    local infoLbl = newLabel(20)
    local healthLbl = newLabel(38, Color3.fromRGB(120,255,120))
    local equipLbl = newLabel(56, Color3.fromRGB(255,255,0))
    local wantedLbl = newLabel(74)

    state.espObjects[other.UserId] = {
        billboard = billboard,
        nameLbl = nameLbl,
        infoLbl = infoLbl,
        healthLbl = healthLbl,
        equipLbl = equipLbl,
        wantedLbl = wantedLbl
    }
end

-- üîÅ ESP updaten
local function updateESPEntry(other)
    local entry = state.espObjects[other.UserId]
    if not entry then return end

    local char = other.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum or hum.Health <= 0 then
        entry.billboard.Enabled = false
        return
    end

    local plrRoot = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not plrRoot then return end

    local dist = (plrRoot.Position - hrp.Position).Magnitude
    if dist > state.espDistance then
        entry.billboard.Enabled = false
        return
    else
        entry.billboard.Enabled = true
    end

    local team = other.Team
    local teamColor = teamColorForTeam(team)

    entry.nameLbl.Text = state.showNames and other.Name or ""
    entry.nameLbl.TextColor3 = teamColor

    if state.showDistance then
        entry.infoLbl.Text = (team and ("["..team.Name.."] ") or "") .. math.floor(dist) .. "m"
    else
        entry.infoLbl.Text = team and ("["..team.Name.."]") or ""
    end

    entry.healthLbl.Text = state.showHealth and ("HP: "..math.floor(hum.Health)) or ""

    if state.showEquipped then
        local tool = char:FindFirstChildOfClass("Tool")
        entry.equipLbl.Text = tool and ("Equipped: "..tool.Name) or "Nothing Equipped"
    else
        entry.equipLbl.Text = ""
    end

    if state.showWanted then
        if hrp:GetAttribute("IsWanted") then
            entry.wantedLbl.Text = "Wanted"
            entry.wantedLbl.TextColor3 = Color3.fromRGB(255,140,0)
        else
            entry.wantedLbl.Text = "Not Wanted"
            entry.wantedLbl.TextColor3 = Color3.fromRGB(0,255,0)
        end
    else
        entry.wantedLbl.Text = ""
    end
end

-- üåÄ Render Loop
RunService.RenderStepped:Connect(function()
    if not state.espEnabled then return end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= plr then
            if not state.espObjects[p.UserId] then
                createESPForPlayer(p)
            end
            updateESPEntry(p)
        end
    end
end)

-- üîî Wenn neuer Spieler joint
Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function()
        if state.espEnabled then
            task.wait(1)
            createESPForPlayer(p)
        end
    end)
end)

-- ‚ùå Wenn Spieler geht ‚Üí ESP entfernen
Players.PlayerRemoving:Connect(function(p)
    local entry = state.espObjects[p.UserId]
    if entry then
        if entry.billboard then entry.billboard:Destroy() end
        state.espObjects[p.UserId] = nil
    end
end)

-- ‚öôÔ∏è Rayfield UI Controls
Tab3:AddToggle({
    Name="‚ö™ Player ESP",
    CurrentValue=false,
    Callback=function(v)
        state.espEnabled = v
        if not v then
            for _,e in pairs(state.espObjects) do
                e.billboard:Destroy()
            end
            state.espObjects = {}
        else
            for _,p in ipairs(Players:GetPlayers()) do
                if p ~= plr then
                    createESPForPlayer(p)
                end
            end
        end
    end
})

Tab3:AddToggle({Name="‚ö™ Show Wanted",CurrentValue=true,Callback=function(v)state.showWanted=v end})
Tab3:AddToggle({Name="‚ö™ Show Names",CurrentValue=true,Callback=function(v)state.showNames=v end})
Tab3:AddToggle({Name="‚ö™ Show Teams",CurrentValue=true,Callback=function(v)state.showTeams=v end})
Tab3:AddToggle({Name="‚ö™ Show Distance",CurrentValue=true,Callback=function(v)state.showDistance=v end})
Tab3:AddToggle({Name="‚ö™ Show Health",CurrentValue=true,Callback=function(v)state.showHealth=v end})
Tab3:AddToggle({Name="‚ö™ Show Equipped",CurrentValue=true,Callback=function(v)state.showEquipped=v end})


Tab3:AddSlider({
	Name = "‚ö™ ESP-Distance",
	Min = 100,
	Max = 2000,
	Default = 50,
	Color = Color3.fromRGB(255,255,255),
	Increment = 50,
	ValueName = "Studs",
    CurrentValue = state.espDistance,
    Callback = function(value)
        state.espDistance = value
    end  
})


Tab4 = Window:MakeTab({
	Name = "Teleport | üåÄ",
	PremiumOnly = false
})

Tab4:AddSection({
	Name = "Teleport-Options"
})

local teleportActive = false
local mouse = LocalPlayer:GetMouse()

Tab4:AddToggle({
	Name = "üîµ left-click teleport",
	CurrentValue = false,
	Callback = function(v) teleportActive = v end,
})

mouse.Button1Down:Connect(function()
	if teleportActive and mouse.Hit then
		LocalPlayer.Character:MoveTo(mouse.Hit.Position + Vector3.new(0, 3, 0))
	end
end)

RunService.Stepped:Connect(function()
	if spinOn and LocalPlayer.Character then
		local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if hrp then
			hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(15), 0)
		end
	end
end)


-- üì¶ Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local VehiclesFolder = workspace:WaitForChild("Vehicles")

-- üîÅ Utils
local function notify(txt)
    OrionLib:MakeNotification({ Title = "Teleport", Content = txt, Duration = 3 })
end

-- üéØ Hilfsfunktion: Tween Move
local function tweenTo(destination)
    local car = VehiclesFolder:FindFirstChild(LocalPlayer.Name)
    if not car then return notify("Kein Fahrzeug gespawnt!") end

    if not car.PrimaryPart then
        car.PrimaryPart = car:FindFirstChild("DriveSeat", true) or car:FindFirstChildWhichIsA("BasePart")
    end
    if not car.PrimaryPart then return notify("Kein PrimaryPart gefunden!") end

    if typeof(destination) == "CFrame" then
        destination = destination.Position
    end

    local startPosition = car.PrimaryPart.Position
    local steps = { startPosition + Vector3.new(0, -5, 0), destination + Vector3.new(0, -5, 0), destination }

    for _, targetPos in ipairs(steps) do
        local distance = (car.PrimaryPart.Position - targetPos).Magnitude
        local duration = distance / 175
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

        local value = Instance.new("CFrameValue")
        value.Value = car:GetPivot()

        value.Changed:Connect(function(newCFrame)
            car:PivotTo(newCFrame)
            if car.PrimaryPart then
                car.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
                car.PrimaryPart.AssemblyAngularVelocity = Vector3.zero
            end
        end)

        local tween = TweenService:Create(value, tweenInfo, { Value = CFrame.new(targetPos) })
        tween:Play()
        tween.Completed:Wait()
        value:Destroy()
    end
end

-- üìç Locations
local function getLocationCFrame(name)
    if name == "Bank" then
        return CFrame.new(-1174.68, 5.87, 3209.03)
    end
    return nil
end

-- üìç Teleport: Nearest Dealer
local function teleportToNearestDealer()
    local car = VehiclesFolder:FindFirstChild(LocalPlayer.Name)
    if not car then return notify("Spawn zuerst dein Auto!") end

    if not car.PrimaryPart then
        car.PrimaryPart = car:FindFirstChild("DriveSeat", true) or car:FindFirstChildWhichIsA("BasePart")
    end

    local closest, dist = nil, math.huge
    for _, dealer in pairs(workspace:WaitForChild("Dealers"):GetChildren()) do
        if dealer:IsA("Model") and dealer.PrimaryPart then
            local d = (LocalPlayer.Character.PrimaryPart.Position - dealer.PrimaryPart.Position).Magnitude
            if d < dist then
                dist = d
                closest = dealer
            end
        end
    end

    if not closest then return notify("Kein Dealer gefunden!") end

    local dealerPos = closest.PrimaryPart.Position
    local dealerCFrame = closest.PrimaryPart.CFrame
    local tpCFrame = CFrame.new(dealerPos - dealerCFrame.LookVector * -10, dealerPos)

    tweenTo(tpCFrame)
   OrionLib:MakeNotification("Zum n√§chsten Dealer teleportiert!")
end


Tab4:AddButton({
    Name = "üîµ nearest Dealer",
    Callback = function()
        teleportToNearestDealer()
    end
})


Tab4:AddSection({ Name = "üîµ Work Places" })

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local VehiclesFolder = workspace:WaitForChild("Vehicles")

local Locations = {
    ["üîµ Police Station"] = CFrame.new(-1658.55, 5.619, 2735.71),
    ["üîµ Fire Station"] = CFrame.new(-963.32, 5.865, 3895.37),
    ["üîµ Bus Company"] = CFrame.new(-1695.80, 5.882, -1274.29),
    ["üîµ Truck Company"] = CFrame.new(652.55, 5.638, 1510.85),
}

local function tweenTo(destination)
    local car = VehiclesFolder:FindFirstChild(LocalPlayer.Name)
    if not car then return end

    car.PrimaryPart = car:FindFirstChild("DriveSeat", true)
    if not car.PrimaryPart then return end

    car.DriveSeat:Sit(LocalPlayer.Character:WaitForChild("Humanoid"))

    if typeof(destination) == "CFrame" then
        destination = destination.Position
    end

    local start = car.PrimaryPart.Position
    local steps = { start + Vector3.new(0,-5,0), destination + Vector3.new(0,-5,0), destination }

    for _, target in ipairs(steps) do
        local dist = (car.PrimaryPart.Position - target).Magnitude
        local duration = dist / 175
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)

        local value = Instance.new("CFrameValue")
        value.Value = car:GetPivot()

        value.Changed:Connect(function(newCFrame)
            car:PivotTo(newCFrame)
            car.DriveSeat.AssemblyLinearVelocity = Vector3.zero
            car.DriveSeat.AssemblyAngularVelocity = Vector3.zero
        end)

        local tween = TweenService:Create(value, tweenInfo, { Value = CFrame.new(target) })
        tween:Play()
        tween.Completed:Wait()
        value:Destroy()
    end
end

local locationNames = {}
for name,_ in pairs(Locations) do table.insert(locationNames,name) end

Tab4:AddDropdown({
    Name = "üîµ Work places",
    Options = locationNames,
    CurrentOption = locationNames[1],
    Flag = "TP_Work",
    Callback = function(option) end
})

Tab4:AddButton({
    Name = "üîµ Teleport",
    Callback = function()
        local choice = OrionLib.Flags["TP_Work"].Value
        if choice and Locations[choice] then
            tweenTo(Locations[choice])
        end
    end
})

----------------------------------------------------------
-- Robbable Places
Tab4:AddSection({ Name = "üîµ Robbable Places" })

local RobbableLocations = {
    ["üîµ Bank"] = CFrame.new(-1174.68, 5.87, 3209.03),
    ["üîµ Yellow Container"] = CFrame.new(1178.71, 28.696, 2321.66),
    ["üîµ Green Container"] = CFrame.new(1182.71, 28.696, 2158.84),
    ["üîµ Jewelry"] = CFrame.new(-346.63, 5.87, 3572.74),
    ["üîµ Ares Fuel"] = CFrame.new(-870.86, 5.622, 1505.16),
    ["üîµ Gas n Go Fuel"] = CFrame.new(-1544.4, 5.619, 3802.16),
    ["üîµ Ossu Fuel"] = CFrame.new(-27.55, 5.622, -754.6),
    ["üîµ Night Club"] = CFrame.new(-1844.95, 5.872, 3211.08),
    ["üîµ Tool Shop"] = CFrame.new(-717.23, 5.654, 729.08),
    ["üîµ Food Shop"] = CFrame.new(-911.50, 5.371, -1169.20),
    ["üîµ Clothing Store"] = CFrame.new(479.05, 3.158, -1452.59)
}

local robNames = {}
for name,_ in pairs(RobbableLocations) do table.insert(robNames,name) end

Tab4:AddDropdown({
    Name = "üîµ Robbable places",
    Options = robNames,
    CurrentOption = robNames[1],
    Flag = "TP_Rob",
    Callback = function(option) end
})

Tab4:AddButton({
    Name = "üîµ Teleport (Robbable)",
    Callback = function()
        local choice = OrionLib.Flags["TP_Rob"].Value
        if choice and RobbableLocations[choice] then
            tweenTo(RobbableLocations[choice])
        end
    end
})

----------------------------------------------------------
-- Usable Places
Tab4:AddSection({ Name = "üîµ Usable Places" })

local UsableLocations = {
    ["üîµ Tuning Garage"] = CFrame.new(-1429.04, 5.57, 143.96),
    ["üîµ Car Dealership"] = CFrame.new(-1454.02, 5.615, 940.83),
    ["üîµ Hospital"] = CFrame.new(-293.16, 5.627, 1053.98),
    ["üîµ Prison"] = CFrame.new(-514.34, 5.615, 2795.94),
}

local useNames = {}
for name,_ in pairs(UsableLocations) do table.insert(useNames,name) end

Tab4:AddDropdown({
    Name = "üîµ Usable places",
    Options = useNames,
    CurrentOption = useNames[1],
    Flag = "TP_Use",
    Callback = function(option) end
})

Tab4:AddButton({
    Name = "üîµ Teleport (Usable)",
    Callback = function()
        local choice = OrionLib.Flags["TP_Use"].Value
        if choice and UsableLocations[choice] then
            tweenTo(UsableLocations[choice])
        end
    end
})




Tab4:AddSection({
	Name = "üîµ Player-Teleport"
})


-- üîß Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local VehiclesFolder = Workspace:WaitForChild("Vehicles")

-- üß≠ Utils
local function notify(title, text, dur)
    OrionLib:MakeNotification({ Title = title, Content = text, Duration = dur or 3 })
end

-- üîπ Spieler-Liste
local selectedPlayer = nil
local function getPlayerList()
    local list = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            table.insert(list, p.Name)
        end
    end
    if #list == 0 then
        table.insert(list, "Keine Spieler gefunden")
    end
    return list
end

-- üîΩ Spieler-Auswahl (Bugfix)
Tab4:AddDropdown({
    Name = "üîµ Select target player",
    Options = getPlayerList(),
    CurrentOption = "",
    Flag = "TargetPlayer",
    Callback = function(Value)
        if typeof(Value) == "table" then
            Value = Value[1]
        end

        if not Value or Value == "" or Value == "Keine Spieler gefunden" then
            selectedPlayer = nil
            OrionLib:MakeNotification("Hinweis", "Kein g√ºltiger Spieler ausgew√§hlt!", 2)
            return
        end

        local found = Players:FindFirstChild(Value)
        if found then
            selectedPlayer = found
            OrionLib:MakeNotification("Ziel gesetzt", "Zielspieler: " .. found.Name, 2)
        else
            selectedPlayer = nil
            OrionLib:MakeNotification("Fehler", "Spieler '" .. tostring(Value) .. "' wurde nicht gefunden!", 3)
        end
    end
})


-- üöó Teleportfunktion
local function TweenCarToPlayer(targetPlayer)
    local car = VehiclesFolder:FindFirstChild(LocalPlayer.Name)
    if not car then return notify("Fehler", "Kein Fahrzeug gefunden!") end

    local driveSeat = car:FindFirstChild("DriveSeat", true)
    if not driveSeat then return notify("Fehler", "Kein DriveSeat gefunden!") end
    car.PrimaryPart = driveSeat

    -- Spieler ins Auto setzen
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum and hum.SeatPart ~= driveSeat then
        pcall(function() driveSeat:Sit(hum) end)
    end

    -- Zielvalidierung
    if not (targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        return notify("Fehler", "Zielspieler ist nicht verf√ºgbar oder nicht geladen.")
    end

    local targetPos = targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 3, 0)
    local distance = (car.PrimaryPart.Position - targetPos).Magnitude
    local duration = math.clamp(distance / 120, 1, 8)

    local cfValue = Instance.new("CFrameValue")
    cfValue.Value = car:GetPivot()

    local connection
    connection = cfValue.Changed:Connect(function(cframe)
        if car and car.Parent then
            car:PivotTo(cframe)
            pcall(function()
                driveSeat.AssemblyLinearVelocity = Vector3.zero
                driveSeat.AssemblyAngularVelocity = Vector3.zero
            end)
        end
    end)

    local tween = TweenService:Create(cfValue, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
        Value = CFrame.new(targetPos)
    })

    tween:Play()
    tween.Completed:Connect(function()
        connection:Disconnect()
        cfValue:Destroy()
        OrionLib:MakeNotification("Fertig!", "Du bist jetzt bei " .. targetPlayer.Name, 3)
    end)
end

-- üöÄ Teleport-Button
Tab4:AddButton({
    Name = "üîµ Teleport to player",
    Callback = function()
        if selectedPlayer then
            TweenCarToPlayer(selectedPlayer)
        else
            OrionLib:MakeNotification("Fehler", "Bitte w√§hle zuerst einen Zielspieler aus!")
        end
    end
})

-- üõ∞ Auto-Tracking-Toggle
local trackingEnabled = false
Tab4:AddToggle({
    Name = "üîµ Follow automatically to player",
    CurrentValue = false,
    Flag = "AutoTrack",
    Callback = function(v)
        trackingEnabled = v
        if v then
            OrionLib:MakeNotification("Aktiviert", "Automatisches Folgen gestartet.", 2)
            task.spawn(function()
                while trackingEnabled and selectedPlayer and selectedPlayer.Character do
                    TweenCarToPlayer(selectedPlayer)
                    task.wait(3)
                end
            end)
        else
            OrionLib:MakeNotification("Deaktiviert", "Automatisches Folgen beendet.", 2)
        end
    end
})



Tab5 = Window:MakeTab({
	Name = "Player | ‚öôÔ∏è",
	PremiumOnly = false
})

Tab5:AddSection({
	Name = "Misc-Options"
})

-- üì¶ Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local RunService = game:GetService("RunService")


-- üìä Variablen
local autoReviveEnabled = false
local healthConnection = nil

-- üîÅ Tween-Funktion
local function tweenTo(destination)
	local VehiclesFolder = Workspace:FindFirstChild("Vehicles")
	local car = VehiclesFolder and VehiclesFolder:FindFirstChild(player.Name)
	if not car then
		OrionLib:MakeNotification({Title="Fehler", Content="Kein Fahrzeug gefunden!", Duration=3})
		return false
	end

	car.PrimaryPart = car:FindFirstChild("DriveSeat", true)
	if car.DriveSeat and player.Character and player.Character:FindFirstChild("Humanoid") then
		car.DriveSeat:Sit(player.Character.Humanoid)
	end

	if typeof(destination) == "CFrame" then
		destination = destination.Position
	end

	local function moveTo(targetPosition)
		local distance = (car.PrimaryPart.Position - targetPosition).Magnitude
		local tweenDuration = distance / 175
		local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

		local value = Instance.new("CFrameValue")
		value.Value = car:GetPivot()

		value.Changed:Connect(function(newCFrame)
			car:PivotTo(newCFrame)
			if car.DriveSeat then
				car.DriveSeat.AssemblyLinearVelocity = Vector3.zero
				car.DriveSeat.AssemblyAngularVelocity = Vector3.zero
			end
		end)

		local tween = TweenService:Create(value, tweenInfo, { Value = CFrame.new(targetPosition) })
		tween:Play()
		tween.Completed:Wait()
		value:Destroy()
	end

	moveTo(car.PrimaryPart.Position + Vector3.new(0, -4, 0))
	moveTo(destination + Vector3.new(0, -4, 0))
	moveTo(destination)
	return true
end

-- üè• Auto-Heilung
local function autoHealAndReturn(originalPosition)
	local char = player.Character or player.CharacterAdded:Wait()
	local humanoid = char:WaitForChild("Humanoid")

	local bed = Workspace:FindFirstChild("Buildings")
		and Workspace.Buildings:FindFirstChild("Hospital")
		and Workspace.Buildings.Hospital:FindFirstChild("HospitalBed")
		and Workspace.Buildings.Hospital.HospitalBed:FindFirstChild("Seat")

	if not bed then
		OrionLib:MakeNotification({Title="Self-Revive Fehler", Content="HospitalBed nicht gefunden!", Duration=4})
		return false
	end

	if humanoid.Sit then
		humanoid.Sit = false
		humanoid.Jump = true
		task.wait(0.1)
	end

	if char:FindFirstChild("HumanoidRootPart") then
		local hrp = char.HumanoidRootPart
		hrp.CFrame = bed.CFrame * CFrame.new(0, 3, 0)
		task.wait(0.2)
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.AssemblyAngularVelocity = Vector3.zero
		hrp.CFrame = bed.CFrame * CFrame.new(0, 0.5, 0)
		task.wait(0.1)
	end

	local attempts = 0
	while not humanoid.Sit and attempts < 5 do
		bed:Sit(humanoid)
		attempts += 1
		task.wait(0.2)
	end

	repeat task.wait(0.2) until humanoid.Health >= humanoid.MaxHealth * 0.27

	humanoid.Sit = false
	humanoid.Jump = true
	task.wait(0.2)

	local car = Workspace.Vehicles:FindFirstChild(player.Name)
	if car and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = car.DriveSeat.CFrame * CFrame.new(0, 2, 0)
		car.DriveSeat:Sit(humanoid)
		task.wait(0.1)
		tweenTo(originalPosition)
	end
end

-- üíâ Hauptpr√ºfung
local function checkHealthAndTeleport()
	local car = Workspace:FindFirstChild("Vehicles") and Workspace.Vehicles:FindFirstChild(player.Name)
	if not car then return end

	local char = player.Character or player.CharacterAdded:Wait()
	local humanoid = char:WaitForChild("Humanoid")
	local originalPos = car:GetPivot().Position
	local hospital = CFrame.new(-120.30, 5.61, 1077.29)

	if humanoid.Health <= humanoid.MaxHealth * 0.27 then
		if tweenTo(hospital) then
			task.wait(2)
			autoHealAndReturn(originalPos)
		end
	else
		OrionLib:MakeNotification({
			Title="Self-Revive",
			Content="You are not dead ‚Äì no action necessary",
			Duration=3
		})
	end
end

-- ‚öôÔ∏è Aktivierungslogik
local function enableAutoRevive(val)
	autoReviveEnabled = val
	if val then
		local char = player.Character or player.CharacterAdded:Wait()
		local humanoid = char:WaitForChild("Humanoid")
		healthConnection = humanoid.HealthChanged:Connect(function(hp)
			if autoReviveEnabled and hp <= humanoid.MaxHealth * 0.27 then
				checkHealthAndTeleport()
			end
		end)
		OrionLib:MakeNotification({Title="Self-Revive activated", Content="Automatisches Heilen aktiv!", Duration=3})
	else
		if healthConnection then
			healthConnection:Disconnect()
			healthConnection = nil
		end
		OrionLib:MakeNotification({Title="Self-Revive disabled", Content="Auto-Heal ausgeschaltet.", Duration=3})
	end
end

-- üîÑ Respawn-Reattach
player.CharacterAdded:Connect(function(char)
	if autoReviveEnabled then
		char:WaitForChild("Humanoid").HealthChanged:Connect(function(hp)
			if hp <= char.Humanoid.MaxHealth * 0.27 then
				checkHealthAndTeleport()
			end
		end)
	end
end)


Tab5:AddButton({
	Name = "‚ö´ Self Revive",
	Callback = function()
		checkHealthAndTeleport()
	end
})



Tab5:AddButton({
    Name = "‚ö´ Change-Job",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player and player.Team then
            local teams = game:GetService("Teams")
            local newTeam = teams:GetChildren()[math.random(1, #teams:GetChildren())]
            player.Team = newTeam
        end
    end,
})

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = game.Players.LocalPlayer

local flying = false
local camCFrame = Camera.CFrame
local speed = 2
local sens = 0.2
local pitch, yaw = 0, 0
local velocity = Vector3.zero

local function toggleFreeCam(state)
	flying = state
	if flying then
		Camera.CameraType = Enum.CameraType.Scriptable
		camCFrame = Camera.CFrame
		local _, y = camCFrame:ToEulerAnglesYXZ()
		yaw = y
		pitch = 0
	else
		Camera.CameraType = Enum.CameraType.Custom
	end
end

RunService.RenderStepped:Connect(function()
	if not flying then return end

	local delta = UserInputService:GetMouseDelta()
yaw = yaw - delta.X * sens * 0.01
pitch = math.clamp(pitch - delta.Y * sens * 0.01, -math.pi/2, math.pi/2)

local rot = CFrame.Angles(0, yaw, 0) * CFrame.Angles(pitch, 0, 0)
local move = Vector3.zero

if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + Vector3.new(0, 0, -1) end
if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move + Vector3.new(0, 0, 1) end
if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move + Vector3.new(-1, 0, 0) end
if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + Vector3.new(1, 0, 0) end
if UserInputService:IsKeyDown(Enum.KeyCode.E) then move = move + Vector3.new(0, 1, 0) end
if UserInputService:IsKeyDown(Enum.KeyCode.Q) then move = move + Vector3.new(0, -1, 0) end

	local isFast = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
	local moveSpeed = isFast and speed * 3 or speed

	-- Bewegung nur bei Taste, keine Restbewegung = kein Wackeln
	velocity = move.Magnitude > 0 and move.Unit * moveSpeed or Vector3.zero
	camCFrame = CFrame.new(camCFrame.Position + rot:VectorToWorldSpace(velocity)) * rot
	Camera.CFrame = camCFrame
end)

-- üì¶ Rayfield Toggle (einbauen in dein VisualsTab oder √§hnliches) Character-Settings
Tab5:AddToggle({
	Name = "‚ö´ FreeCam",
	CurrentValue = false,
	Callback = function(state)
		toggleFreeCam(state)
	end
})

speed = 2 -- Geschwindigkeit der FreeCam
Tab5:AddSlider({
	Name = "‚ö´ FreeCam Speed",
	Min = 1,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "Geschwindigkeit",
	CurrentValue = speed,
    Callback = function(value)
        speed = value
    end,  
})


local noclip = false
Tab5:AddToggle({
	Name = "‚ö´ Noclip",
	CurrentValue = false,
	Callback = function(state)
		noclip = state
	end,
})

RunService.Stepped:Connect(function()
	if noclip and LocalPlayer.Character then
		for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
end)


local fpsText = Drawing.new("Text")
fpsText.Size = 30
fpsText.Position = Vector2.new(10, 10)
fpsText.Color = Color3.fromRGB(0, 255, 255)
fpsText.Outline = true
fpsText.Visible = true
local lastTime, fps = tick(), 0

RunService.RenderStepped:Connect(function()
	local now = tick()
	fps = math.floor(1 / (now - lastTime))
	lastTime = now
	fpsText.Text = "FPS: " .. tostring(fps)
end)

Tab5:AddSection({
	Name = "Character-Settings"
})

Tab5:AddParagraph("Fly INFO","Press V to Fly")

-- üì¶ Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- üîß Fly Variablen
local flyingSpeed = 50
local isFlying = false
local attachment, alignPosition, alignOrientation

-- ‚úàÔ∏è Fly Funktionen
local function enableFly()
    local character = player.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not (root and humanoid) then return end

    attachment = Instance.new("Attachment", root)

    alignPosition = Instance.new("AlignPosition")
    alignPosition.Attachment0 = attachment
    alignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment
    alignPosition.MaxForce = 5000
    alignPosition.Responsiveness = 45
    alignPosition.Parent = root

    alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.Attachment0 = attachment
    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOrientation.MaxTorque = 5000
    alignOrientation.Responsiveness = 45
    alignOrientation.Parent = root

    humanoid.PlatformStand = true
    isFlying = true

    local lastPosition = root.Position
    alignPosition.Position = lastPosition

    task.spawn(function()
        while isFlying and root and humanoid do
            local moveDir = Vector3.zero
            local camCFrame = workspace.CurrentCamera.CFrame

            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir += camCFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir -= camCFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir -= camCFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir += camCFrame.RightVector end

            if moveDir.Magnitude > 0 then
                moveDir = moveDir.Unit
                local newPos = lastPosition + (moveDir * flyingSpeed * RunService.Heartbeat:Wait())
                alignPosition.Position = newPos
                lastPosition = newPos
            end

            alignOrientation.CFrame = CFrame.new(Vector3.zero, camCFrame.LookVector)
            RunService.Heartbeat:Wait()
        end
    end)
end

local function disableFly()
    isFlying = false
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    if humanoid then humanoid.PlatformStand = false end
    if attachment then attachment:Destroy() end
    if alignPosition then alignPosition:Destroy() end
    if alignOrientation then alignOrientation:Destroy() end
end

-- üîò Fly Toggle
Tab5:AddToggle({
    Name = "‚ö´ Fly",
    CurrentValue = false,
    Callback = function(v)
        if v then
            enableFly()
        else
            disableFly()
        end
    end
})


Tab5:AddSlider({
	Name = "‚ö´Fly Speed",
	Min = 10,
	Max = 150,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "Speed",
	CurrentValue = flyingSpeed,
    Callback = function(v)
        flyingSpeed = v
    end   
})

-- ‚å® Keybind V f√ºr Fly Toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.V then
        if isFlying then
            disableFly()
        else
            enableFly()
        end
    end
end)


local spinOn = false
Tab5:AddToggle({
    Name = "‚ö´ Spinbot",
    CurrentValue = false,
    Callback = function(val)
        spinOn = val
    end,
})

-- Spinbot logic: rotates the player's character continuously while enabled
RunService.Stepped:Connect(function()
    if spinOn and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(60), 0)
    end
end)

Tab5:AddButton({
    Name = "‚ö´ Instant-Respawn",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player.Character then
            player.Character:BreakJoints()
            wait(0.1)
            player:LoadCharacter()
        end
    end,
})

Tab6 = Window:MakeTab({
	Name = "Car | üõ∫",
	Icon = "",
	PremiumOnly = false
})

Tab6:AddSection({
	Name = "Car-Tuning"
})

local VEHICLE_FOLDER_NAME = "Vehicles"

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local workspace = game:GetService("Workspace")


-- State
local currentLevel = 0
local maxLevel = 6
local attrArmor = 0
local attrBrakes = 0
local attrEngine = 0

-- Helpers
local function notify(title, content, duration)
	pcall(function()
		if Rayfield and Rayfield.Notify then
			OrionLib:MakeNotification({Title = title or "Tuning", Content = content or "", Duration = duration or 2})
		end
	end)
end

local function findPlayerVehicle()
	local vehicleFolder = workspace:FindFirstChild(VEHICLE_FOLDER_NAME)
	if not vehicleFolder then return nil, "Vehicle-Folder nicht gefunden" end
	local playerVehicle = vehicleFolder:FindFirstChild(player.Name)
	if not playerVehicle then return nil, "Fahrzeug nicht gefunden" end
	return playerVehicle
end

local function applyAttributesToVehicleByValues(armor, brakes, engine)
	local playerVehicle, err = findPlayerVehicle()
	if not playerVehicle then return false, err end
	-- safe set (pcall inside)
	local ok, e = pcall(function()
		playerVehicle:SetAttribute("armorLevel", armor)
		playerVehicle:SetAttribute("brakesLevel", brakes)
		playerVehicle:SetAttribute("engineLevel", engine)
	end)
	if not ok then
		return false, tostring(e)
	end
	return true
end

local function applyLevelToAll(level)
	attrArmor = level
	attrBrakes = level
	attrEngine = level
	return applyAttributesToVehicleByValues(attrArmor, attrBrakes, attrEngine)
end

-- SICHERE Setter-Funktion f√ºr Slider-UI (vermeidet callback errors)
local function safeSetSliderValue(slider, value)
	if not slider then return end
	pcall(function()
		-- probiere die gebr√§uchlichsten Methoden, falls vorhanden
		if type(slider.SetValue) == "function" then
			slider:SetValue(value)
		elseif type(slider.setValue) == "function" then
			slider.setValue(slider, value)
		elseif type(slider.Update) == "function" then
			slider:Update(value)
		elseif type(slider.UpdateValue) == "function" then
			slider:UpdateValue(value)
		-- falls keine Methode existiert, ist das kein Problem ‚Äî UI bleibt unver√§ndert.
		end
	end)
end


Tab6:AddSlider({
	Name = "üü¢ Engine",
	Min = 0,
	Max = maxLevel,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "",
	CurrentValue = attrEngine,
	Callback = function(value)
		attrEngine = math.floor(tonumber(value) or 0)
		local ok, err = applyAttributesToVehicleByValues(attrArmor, attrBrakes, attrEngine)
		if ok then
			currentLevel = math.max(attrArmor, attrBrakes, attrEngine)
			OrionLib:MakeNotification("Tuning", "Engine set to "..tostring(attrEngine), 1)
			safeSetSliderValue(levelSlider, currentLevel)
		else
			OrionLib:MakeNotification("Tuning Error", tostring(err), 2)
		end
	end   
})



Tab6:AddSlider({
	Name = "üü¢ Brakes",
	Min = 0,
	Max = maxLevel,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "",
	CurrentValue = attrBrakes,
	Callback = function(value)
		attrBrakes = math.floor(tonumber(value) or 0)
		local ok, err = applyAttributesToVehicleByValues(attrArmor, attrBrakes, attrEngine)
		if ok then
			currentLevel = math.max(attrArmor, attrBrakes, attrEngine)
			OrionLib:MakeNotification("Tuning", "Brakes set to "..tostring(attrBrakes), 1)
			safeSetSliderValue(levelSlider, currentLevel)
		else
			OrionLib:MakeNotification("Tuning Error", tostring(err), 2)
		end
	end  
})



Tab6:AddSlider({
	Name = "üü¢ Armor",
	Min = 0,
	Max = maxLevel,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "",
	CurrentValue = attrArmor,
	Callback = function(value)
		attrArmor = math.floor(tonumber(value) or 0)
		local ok, err = applyAttributesToVehicleByValues(attrArmor, attrBrakes, attrEngine)
		if ok then
			currentLevel = math.max(attrArmor, attrBrakes, attrEngine)
			OrionLib:MakeNotification("Tuning", "Armor set to "..tostring(attrArmor), 1)
			safeSetSliderValue(levelSlider, currentLevel)
		else
			OrionLib:MakeNotification("Tuning Error", tostring(err), 2)
		end
	end   
})


local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- üîç Hilfsfunktion: erkennt ob ein Part eine Felge ist
local function isRim(part)
	local name = part.Name:lower()
	return name:find("rim")
		or name:find("wheel")
		or name:find("reifen")
		or name:find("felge")
		or (part.Material == Enum.Material.Metal and part.Size.X < 3 and part.Size.Y < 3)
end

-- üé® Farbupdate-Funktion (ohne Lichtfarbe)
local function updateCarColors(mainColor, rimColor)
	pcall(function()
		local vehicles = Workspace:FindFirstChild("Vehicles")
		if not vehicles then return end

		local car = vehicles:FindFirstChild(LocalPlayer.Name)
		if not car then return end

		for _, part in ipairs(car:GetDescendants()) do
			if part:IsA("BasePart") or part:IsA("UnionOperation") or part:IsA("MeshPart") then

				-- Hauptfarbe (Karosserie)
				if part.Name:lower():find("body") or part.Name:lower():find("chassis") then
					part.Color = mainColor
				end

				-- Felgenfarbe
				if isRim(part) then
					part.Color = rimColor
					part.Material = Enum.Material.Metal
				end
			end
		end
	end)
end

-- üß± Standardfarben
local mainColor = Color3.fromRGB(255, 255, 255)
local rimColor = Color3.fromRGB(120, 120, 120)

-- üé® UI Farbauswahl (nur Body + Wheels)
Tab6:AddColorpicker({
	Name = "üü¢ Body Color",
	Color = mainColor,
	Callback = function(c)
		mainColor = c
		updateCarColors(mainColor, rimColor)
	end
})

Tab6:AddColorpicker({
	Name = "üü¢ Wheel Color",
	Color = rimColor,
	Callback = function(c)
		rimColor = c
		updateCarColors(mainColor, rimColor)
	end
})


local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Funktion: Nummernschild √§ndern
local function setPlateText(text)
    pcall(function()
        local vehicles = Workspace:FindFirstChild("Vehicles")
        if not vehicles then return end

        local car = vehicles:FindFirstChild(LocalPlayer.Name)
        if not car then return end

        local body = car:FindFirstChild("Body", true)
        if not body then return end

        local plates = body:FindFirstChild("LicensePlates")
        if not plates then return end

        for _, plate in ipairs(plates:GetChildren()) do
            if plate:FindFirstChild("Gui") and plate.Gui:FindFirstChild("TextLabel") then
                plate.Gui.TextLabel.Text = text
                plate.Gui.TextLabel.TextColor3 = Color3.fromRGB(29, 53, 53)
            end
            if plate:FindFirstChild("Decal") then
                plate.Decal.Color3 = Color3.fromRGB(255, 255, 255)
            end
        end
    end)
end



Tab6:AddTextbox({
	Name = "üü¢ Custom Plate",
	PlaceholderText = "TrixoBeste",
	RemoveTextAfterFocusLost = false,
	Callback = function(value)
		setPlateText(value)
	end
})


-- üîß Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- üöó Fahrzeug finden
local function getVehicle()
    local vehicles = Workspace:FindFirstChild("Vehicles")
    if not vehicles then return nil end
    return vehicles:FindFirstChild(LocalPlayer.Name)
end

-- üß© SpringConstraints finden
local function getSprings(vehicle)
    local springs = {}
    if not vehicle then return springs end
    for _, obj in ipairs(vehicle:GetDescendants()) do
        if obj:IsA("SpringConstraint") then
            table.insert(springs, obj)
        end
    end
    return springs
end

-- ‚öô Funktion: Fahrwerksh√∂he setzen (ohne Notify)
local function setSuspensionHeight(height)
    local vehicle = getVehicle()
    if not vehicle then return end

    for _, spring in ipairs(getSprings(vehicle)) do
        spring.FreeLength = height
    end
end

-- üéö Slider f√ºr Gesamth√∂he
local currentHeight = 2.5
Tab6:AddSlider({
	Name = "üü¢ Total height Car",
	Min = 1,
	Max = 2.5,
	Default = 2,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "Studs",
	CurrentValue = currentHeight,
    Callback = function(value)
        currentHeight = value
        setSuspensionHeight(value)
    end   
})


Tab6:AddSection({
	Name = "Car-Fly-Options"
})



-- üì¶ Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- üöó Car Fly Variablen
local carFlyEnabled = false
local flightSpeed = 2

-- ‚úàÔ∏è Car Fly Logic
RunService.RenderStepped:Connect(function()
    if carFlyEnabled and player.Character and player.Character:FindFirstChild("Humanoid") then
        if player.Character.Humanoid.Sit then
            local SeatPart = player.Character.Humanoid.SeatPart
            if SeatPart and SeatPart.Name == "DriveSeat" then
                local Vehicle = SeatPart.Parent
                if Vehicle then
                    if not Vehicle.PrimaryPart then
                        Vehicle.PrimaryPart = SeatPart
                    end

                    local PrimaryPartCFrame = Vehicle:GetPrimaryPartCFrame()
                    local camLook = workspace.CurrentCamera.CFrame.LookVector

                    Vehicle:SetPrimaryPartCFrame(
                        CFrame.new(PrimaryPartCFrame.Position, PrimaryPartCFrame.Position + camLook) *
                        CFrame.new(
                            ((UserInputService:IsKeyDown(Enum.KeyCode.D) and flightSpeed or 0) -
                            (UserInputService:IsKeyDown(Enum.KeyCode.A) and flightSpeed or 0)) * flightSpeed,
                            ((UserInputService:IsKeyDown(Enum.KeyCode.E) and flightSpeed / 2 or 0) -
                            (UserInputService:IsKeyDown(Enum.KeyCode.Q) and flightSpeed / 2 or 0)) * flightSpeed,
                            ((UserInputService:IsKeyDown(Enum.KeyCode.S) and flightSpeed or 0) -
                            (UserInputService:IsKeyDown(Enum.KeyCode.W) and flightSpeed or 0)) * flightSpeed
                        )
                    )
                    SeatPart.AssemblyLinearVelocity = Vector3.zero
                    SeatPart.AssemblyAngularVelocity = Vector3.zero
                end
            end
        end
    end
end)

Tab6:AddParagraph("Car Fly INFO","Press X to FLY")

-- üéõ Car Fly Toggle
Tab6:AddToggle({
    Name = "üü¢ Car Fly",
    CurrentValue = false,
    Flag = "üü¢ CarFly",
    Callback = function(v)
        carFlyEnabled = v
        OrionLib:MakeNotification({ Title = "Car Fly", Content = v and "Aktiviert!" or "Deaktiviert!", Duration = 2 })
    end
})



Tab6:AddSlider({
	Name = "üü¢ Car Fly Speed",
	Min = 1.5,
	Max = 2,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "Speed",
	CurrentValue = flightSpeed,
    Callback = function(v)
        flightSpeed = v
    end   
})

-- ‚å® Keybind X f√ºr Car Fly Toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.X then
            carFlyEnabled = not carFlyEnabled
            OrionLib:MakeNotification({ 
                Title = "Car Fly", 
                Content = carFlyEnabled and "Aktiviert!" or "Deaktiviert!", 
                Duration = 2 
            })
        end
    end
end)



Tab6:AddSection({
	Name = "Car-Mods"
})


function bringCarToPlayer()
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:Wait()
	local root = char:WaitForChild("HumanoidRootPart", 2)
	local car = workspace:FindFirstChild("Vehicles") and workspace.Vehicles:FindFirstChild(player.Name)

	if car and root then
		local seat = car:FindFirstChild("DriveSeat", true)
		if not seat then
			OrionLib:MakeNotification({ Title = "‚ùå Kein Sitz", Content = "DriveSeat im Fahrzeug nicht gefunden", Duration = 4 })
			return
		end

		car.PrimaryPart = seat
		local forward = root.CFrame.LookVector * 10
		local targetCFrame = CFrame.new(root.Position + forward, root.Position)

		car:SetPrimaryPartCFrame(targetCFrame)

		task.wait(0.5)

		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then seat:Sit(humanoid) end

		OrionLib:MakeNotification({
			Title = "‚úÖ Auto gebracht",
			Content = "Dein Fahrzeug wurde zu dir teleportiert und du sitzt drin.",
			Duration = 4
		})
	else
		OrionLib:MakeNotification({
			Title = "‚ùå Fehler",
			Content = "Kein Fahrzeug gefunden oder du hast keinen Charakter.",
			Duration = 4
		})
	end
end

-- üîò Rayfield Button
Tab6:AddButton({
	Name = "üü¢ Bring-Car",
	Callback = function()
		bringCarToPlayer()
	end,
})

-- üßç Funktion: Spieler aus Fahrzeug ‚Äûrausschleudern‚Äú
function exitCar()
	local character = game.Players.LocalPlayer.Character
	if character and character:FindFirstChild("Humanoid") then
		character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	end
end

-- üîò Rayfield Button: Exit Car
Tab6:AddButton({
	Name = "üü¢ Exit Car",
	Callback = function()
		exitCar()
	end
})

function teleportCarToNearestDealer()
	local car = workspace:FindFirstChild("Vehicles") and workspace.Vehicles:FindFirstChild(LocalPlayer.Name)
	if not car or not car:FindFirstChild("DriveSeat", true) then return end

	local driveSeat = car:FindFirstChild("DriveSeat", true)
	car.PrimaryPart = driveSeat
	if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		driveSeat:Sit(LocalPlayer.Character.Humanoid)
	end

	local closestDealer, shortest = nil, math.huge
	for _, dealer in ipairs(workspace:WaitForChild("Dealers"):GetChildren()) do
		if dealer:IsA("Model") and dealer:FindFirstChild("PrimaryPart") then
			local dist = (dealer.PrimaryPart.Position - driveSeat.Position).Magnitude
			if dist < shortest then
				shortest = dist
				closestDealer = dealer
			end
		end
	end
	if not closestDealer then return end

	local function tweenTo(pos)
		local tweenInfo = TweenInfo.new((car.PrimaryPart.Position - pos).Magnitude / 175, Enum.EasingStyle.Linear)
		local goal = {CFrame = CFrame.new(pos)}
		local proxy = Instance.new("CFrameValue")
		proxy.Value = car:GetPivot()
		proxy:GetPropertyChangedSignal("Value"):Connect(function()
			car:PivotTo(proxy.Value)
			driveSeat.AssemblyLinearVelocity = Vector3.zero
			driveSeat.AssemblyAngularVelocity = Vector3.zero
		end)
		TweenService:Create(proxy, tweenInfo, {Value = CFrame.new(pos)}):Play()
	end

	local dealerPos = closestDealer.PrimaryPart.Position - closestDealer.PrimaryPart.CFrame.LookVector * 10
	tweenTo(dealerPos)
end

Tab6:AddButton({
	Name = "üü¢ Sit in Car",
	Callback = function()
		teleportCarToNearestDealer()
	end
})

Tab6:AddSection({
	Name = "Crazy Mods"
})

Tab6:AddParagraph("Fling INFO","ONLY IN CAR FLY")

-- Values
flingPower = 5000
hiddenfling = false

Players = game:GetService("Players")
RunService = game:GetService("RunService")
lp = Players.LocalPlayer
UserInputService = game:GetService("UserInputService")

-- Detection (beibehalten)
ReplicatedStorage = game:GetService("ReplicatedStorage")
if not ReplicatedStorage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
	detection = Instance.new("Decal")
	detection.Name = "juisdfj0i32i0eidsuf0iok"
	detection.Parent = ReplicatedStorage
end

-- Fling Loop exakt wie original
function fling()
	local hrp, c, vel, movel = nil, nil, nil, 0.1

	while true do
		RunService.Heartbeat:Wait()
		if hiddenfling then

			while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
				RunService.Heartbeat:Wait()
				c = lp.Character
				hrp = c and c:FindFirstChild("HumanoidRootPart")
			end

			if hiddenfling and hrp then
				vel = hrp.Velocity

				hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
				RunService.RenderStepped:Wait()

				if hrp and hrp.Parent then
					hrp.Velocity = vel
				end

				RunService.Stepped:Wait()

				if hrp and hrp.Parent then
					hrp.Velocity = vel + Vector3.new(0, movel, 0)
					movel = movel * -1
				end
			end
		end
	end
end

task.spawn(fling)

-- Toggle
Tab6:AddToggle({
    Name = "üü¢ Fling ",
    CurrentValue = false,
    Callback = function(Value)
        hiddenfling = Value
    end,
})


player = game:GetService("Players").LocalPlayer
RunService = game:GetService("RunService")
vehicleGodMode = false
lastVehicle = nil

-- üöÄ Fahrzeugstatus aktualisieren
RunService.Heartbeat:Connect(function()
	if not vehicleGodMode then return end

	if not lastVehicle or not lastVehicle.Parent then
		local vehiclesFolder = workspace:FindFirstChild("Vehicles")
		lastVehicle = vehiclesFolder and vehiclesFolder:FindFirstChild(player.Name)
	end

	if lastVehicle then
		lastVehicle:SetAttribute("IsOn", true)
		lastVehicle:SetAttribute("currentHealth", 500)
		lastVehicle:SetAttribute("currentFuel", math.huge)
	end
end)

-- üîò Rayfield Toggle
Tab6:AddToggle({
	Name = "üü¢ Car-Godmode",
	CurrentValue = false,
	Flag = "CarGodModeToggle",
	Callback = function(Value)
		vehicleGodMode = Value
		if not Value then lastVehicle = nil end
	end
})


-- üü¢ Status-Variable
STATE = "normal"

-- üü¢ Status-Variable (NICHT automatisch aktiv)
local GhostEnabled = false
local lastColor = nil

-- üöó Funktion zum Umschalten der Materialeffekte
local function changeCarToGhost(state)
    local car = workspace.Vehicles:FindFirstChild(game.Players.LocalPlayer.Name)
    if not car then return end

    local bodyFolder = car:FindFirstChild("Body")
    if not bodyFolder then return end

    local part = bodyFolder:FindFirstChild("Body") or bodyFolder:FindFirstChild("Main")
    if not part or not part:IsA("MeshPart") then return end

    if state then
        -- üîÆ Speichere originale Farbe einmal
        if not lastColor then
            lastColor = part.Color
        end

        part.Material = Enum.Material.ForceField
        part.Color = Color3.fromRGB(29, 53, 53) -- Ghost-Teal
    else
        -- üîÅ Zur√ºcksetzen
        part.Material = Enum.Material.SmoothPlastic
        part.Color = lastColor or Color3.fromRGB(255, 255, 255)
    end
end

-- üß† Rayfield Toggle ‚Äì aktiviert NUR beim Anklicken!
Tab6:AddToggle({
    Name = "üü¢ Car Ghost",
    Default = false,
    Callback = function(Value)  -- ‚ö†Ô∏è Wichtig: Value benutzen!
        GhostEnabled = Value
        changeCarToGhost(Value)
    end
})

carESPEnabled = false
highlights = {}

function toggleCarESP(state)
	carESPEnabled = state

	-- Vorhandene Highlights entfernen
	for _, h in pairs(highlights) do
		if h and h.Parent then
			h:Destroy()
		end
	end
	highlights = {}

	if not carESPEnabled then return end

	-- Neue Highlights hinzuf√ºgen
	local vehicles = workspace:FindFirstChild("Vehicles")
	if vehicles then
		for _, vehicle in pairs(vehicles:GetChildren()) do
			if vehicle:IsA("Model") and vehicle:FindFirstChildWhichIsA("BasePart") then
				local highlight = Instance.new("Highlight")
				highlight.Adornee = vehicle
				highlight.FillColor = Color3.fromRGB(255, 0, 0)
				highlight.FillTransparency = 0.5
				highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
				highlight.OutlineTransparency = 0
				highlight.Parent = vehicle
				table.insert(highlights, highlight)
			end
		end
	end
end

-- Toggle in Rayfield
Tab6:AddToggle({
	Name = "üü¢ Car-Esp",
	CurrentValue = false,
	Flag = "CarESP",
	Callback = function(Value)
		toggleCarESP(Value)
	end,
})



Tab6:AddSection({
	Name = "Speed-Mods"
})


-- State
boostEnabled = false
boostConnection = nil
speedValue = 250 -- default studs/sec, einstellbar per Slider

-- Health-protection state
healthConn = nil
originalMaxHealth = nil
humanoidRef = nil

-- Helper: get player's humanoid & HRP
function getCharacterParts()
    if not player.Character then return nil end
    local char = player.Character
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("LowerTorso")
    return char, humanoid, hrp
end

-- Apply velocity each frame (enforced)
function startBoostEnforcer()
    if boostConnection then return end
    boostConnection = RunService.RenderStepped:Connect(function()
        if not boostEnabled then return end
        local char, humanoid, hrp = getCharacterParts()
        if hrp and hrp.Parent and boostEnabled then
            -- apply forward velocity while preserving vertical velocity
            local forward = hrp.CFrame.LookVector
            local currentY = 0
            -- prefer AssemblyLinearVelocity if available
            local ok, av = pcall(function() return hrp.AssemblyLinearVelocity end)
            if ok and type(av) == "Vector3" then currentY = av.Y else currentY = hrp.Velocity.Y end

            local desired = Vector3.new(forward.X * speedValue, currentY, forward.Z * speedValue)
            pcall(function()
                -- AssemblyLinearVelocity is preferred
                if hrp and hrp.Parent then
                    hrp.AssemblyLinearVelocity = desired
                else
                    hrp.Velocity = desired
                end
            end)
        end
    end)
end

function stopBoostEnforcer()
    if boostConnection then
        pcall(function() boostConnection:Disconnect() end)
        boostConnection = nil
    end
end

-- Health protection: prevent any damage by keeping Health at MaxHealth
function enableNoDamage()
    -- cleanup existing
    if healthConn then
        pcall(function() healthConn:Disconnect() end)
        healthConn = nil
    end

    local char, humanoid, hrp = getCharacterParts()
    if not humanoid then return end
    humanoidRef = humanoid

    -- store original MaxHealth to restore later
    originalMaxHealth = humanoid.MaxHealth

    -- increase MaxHealth to a high value so one-shot damage is less likely
    pcall(function()
        humanoid.MaxHealth = math.max(humanoid.MaxHealth, 100000)
        humanoid.Health = humanoid.MaxHealth
    end)

    -- whenever Health changes, restore it to MaxHealth
    healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        pcall(function()
            if humanoid and humanoid.Parent then
                if humanoid.Health < humanoid.MaxHealth then
                    humanoid.Health = humanoid.MaxHealth
                end
            end
        end)
    end)
end

function disableNoDamage()
    -- disconnect health protector
    if healthConn then
        pcall(function() healthConn:Disconnect() end)
        healthConn = nil
    end
    -- restore MaxHealth if possible
    if humanoidRef and humanoidRef.Parent and originalMaxHealth then
        pcall(function()
            humanoidRef.MaxHealth = originalMaxHealth
            humanoidRef.Health = math.clamp(humanoidRef.Health, 0, humanoidRef.MaxHealth)
        end)
    end
    humanoidRef = nil
    originalMaxHealth = nil
end

-- Toggle function combining boost and no-damage
function enableSafeSpeedBoost(val)
    boostEnabled = val
    if val then
        startBoostEnforcer()
        enableNoDamage()
    else
        stopBoostEnforcer()
        disableNoDamage()
    end
end

-- Ensure protection re-applies on respawn
player.CharacterAdded:Connect(function(char)
    -- slight delay to allow humanoid to initialize
    task.wait(0.2)
    if boostEnabled then
        -- re-enable protections for new character
        enableNoDamage()
        -- boost enforcer already uses getCharacterParts(), so continues working
    end
end)



Tab6:AddSlider({
	Name = "üü¢ Boost Speed",
	Min = 0,
	Max = 300,
	Default = 5,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "KMH",
	CurrentValue = speedValue,
    Callback = function(value)
        speedValue = math.floor(tonumber(value) or speedValue)
        -- immediate feedback: if boosting, no need to restart connection (enforcer reads speedValue each frame)
        pcall(function() OrionLib:MakeNotification({Title = "Speed", Content = "Speed gesetzt: "..tostring(speedValue), Duration = 1}) end)
    end   
})

-- Toggle on/off
Tab6:AddToggle({
    Name = "üü¢ Speed Boost (Safe Mode)",
    CurrentValue = false,
    Flag = "BoostToggle",
    Callback = function(Value)
        enableSafeSpeedBoost(Value)
        if Value then
            pcall(function() OrionLib:MakeNotification({Title = "Boost", Content = "Boost aktiviert (Kein Schaden)", Duration = 2}) end)
        else
            pcall(function() OrionLib:MakeNotification({Title = "Boost", Content = "Boost deaktiviert", Duration = 2}) end)
        end
    end
})

-- Clean up on script end (if executor supports)
function cleanup()
    stopBoostEnforcer()
    disableNoDamage()
end

-- Attempt cleanup on unload (some executors support this)
if syn and syn.protect_gui then
    -- noop, leave it
end

Tab7 = Window:MakeTab({
	Name = "Police | üëÆ",
	Icon = "",
	PremiumOnly = false
})

Tab7:AddSection({
	Name = "üîµ Radar-Settings"
})

-- Auto AFK-Breaker
function EnableAntiAFK()
    for _, conn in ipairs(getconnections(game:GetService("Players").LocalPlayer.Idled)) do
        conn:Disable()
    end
end

Tab7:AddButton({
    Name = "üîµ Anti-AFK",
    Callback = EnableAntiAFK
})





Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
Workspace = game:GetService("Workspace")
LocalPlayer = Players.LocalPlayer


-- Config
local REMOTE_FOLDER_NAME = "MW5"
local REMOTE_ID = "f84ea8db-e793-4805-ba8c-ec190e8516d9"

RadarFarmEnabled = false

function notify(title, content, dur)
    if Rayfield and Rayfield.Notify then
        pcall(function() OrionLib:MakeNotification({ Title = title, Content = content, Duration = dur or 3 }) end)
    else
        warn(title .. ": " .. tostring(content))
    end
end

function resolveRemote()
    -- Versuche mit WaitForChild (timeout), damit wir nicht ewig h√§ngen bleiben
    local folder = nil
    local ok, err = pcall(function() folder = ReplicatedStorage:WaitForChild(REMOTE_FOLDER_NAME, 5) end)
    if not ok or not folder then
        return nil, "Remote folder '" .. REMOTE_FOLDER_NAME .. "' not found"
    end

    local remote = nil
    ok, err = pcall(function() remote = folder:WaitForChild(REMOTE_ID, 5) end)
    if not ok or not remote then
        return nil, "Remote id '" .. REMOTE_ID .. "' not found in folder '" .. REMOTE_FOLDER_NAME .. "'"
    end

    return remote, nil
end

function startRadarFarm()
    local radarRemote, errMsg = resolveRemote()
    if not radarRemote then
        OrionLib:MakeNotification("RadarFarm error", errMsg or "Remote not found", 4)
        return
    end

    OrionLib:MakeNotification("RadarFarm", "Starting radar farm...", 3)
    -- Hauptloop
    while RadarFarmEnabled do
        local char = LocalPlayer.Character
        if not char then
            -- warte kurz, falls Charakter noch nicht geladen
            char = LocalPlayer.CharacterAdded and LocalPlayer.CharacterAdded:Wait() or nil
        end

        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local radarGun = char and char:FindFirstChild("Radar Gun")

        if hrp and radarGun then
            local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
            if vehiclesFolder then
                -- kopiere children in eine Tabelle, falls w√§hrend Iteration ver√§ndert wird
                local vehicles = vehiclesFolder:GetChildren()
                for _, vehicle in ipairs(vehicles) do
                    if vehicle and vehicle:IsA("Model") then
                        local driveSeat = vehicle:FindFirstChild("DriveSeat")
                        if driveSeat and driveSeat.Position and driveSeat.Occupant then
                            local ok, dir = pcall(function()
                                local d = (driveSeat.Position - hrp.Position)
                                if d.Magnitude == 0 then
                                    return nil
                                end
                                return d.Unit
                            end)

                            if ok and dir then
                                -- immer pcall beim FireServer um Fehler zu vermeiden
                                pcall(function()
                                    if radarRemote and radarRemote.FireServer then
                                        radarRemote:FireServer(radarGun, driveSeat.Position, dir)
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end

        task.wait(1)
    end

    OrionLib:MakeNotification("RadarFarm", "Radar farm stopped.", 2)
end

Tab7:AddToggle({
    Name = "üîµ Radar Farm",
    CurrentValue = false,
    Flag = "RadarFarm",
    Callback = function(Value)
        RadarFarmEnabled = Value
        if Value then
            task.spawn(function()
                -- starte den Loop in einem Task
                startRadarFarm()
            end)
        else
            OrionLib:MakeNotification("RadarFarm", "Stopping radar farm...", 1)
        end
    end
})


-- üì¶ Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local VehiclesFolder = workspace:WaitForChild("Vehicles")

-- üèÅ Orte
local Locations = {
    ["üîµ Kreisel"] = CFrame.new(-1067.5, 44.4, 2700.9),
    ["üîµ Kirche"] = CFrame.new(-891.3,169.8,3130.9),
    ["üîµ Bester Spot"] = CFrame.new(-1145.3 , 5.5  ,2802.7),
}

-- üöó Tween Teleport Funktion
local function tweenTo(destination)
    local car = VehiclesFolder:FindFirstChild(LocalPlayer.Name)
    if not car then 
        return OrionLib:MakeNotification({ Title="Fehler", Content="Spawn zuerst dein Auto!", Duration=3 }) 
    end

    car.PrimaryPart = car:FindFirstChild("DriveSeat", true)
    if not car.PrimaryPart then 
        return OrionLib:MakeNotification({ Title="Fehler", Content="Kein PrimaryPart gefunden!", Duration=3 }) 
    end

    car.DriveSeat:Sit(LocalPlayer.Character:WaitForChild("Humanoid"))

    if typeof(destination) == "CFrame" then
        destination = destination.Position
    end

    local start = car.PrimaryPart.Position
    local steps = { start + Vector3.new(0, -5, 0), destination + Vector3.new(0, -5, 0), destination }

    for _, target in ipairs(steps) do
        local dist = (car.PrimaryPart.Position - target).Magnitude
        local duration = dist / 175
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

        local value = Instance.new("CFrameValue")
        value.Value = car:GetPivot()

        value.Changed:Connect(function(newCFrame)
            car:PivotTo(newCFrame)
            car.DriveSeat.AssemblyLinearVelocity = Vector3.zero
            car.DriveSeat.AssemblyAngularVelocity = Vector3.zero
        end)

        local tween = TweenService:Create(value, tweenInfo, { Value = CFrame.new(target) })
        tween:Play()
        tween.Completed:Wait()
        value:Destroy()
    end
end

-- üîΩ Keys (Ortsnamen) extrahieren
local locationNames = {}
for name, _ in pairs(Locations) do
    table.insert(locationNames, name)
end

-- üìå Dropdown
Tab7:AddDropdown({
    Name = "üîµ RadarFarm places",
    Options = locationNames,
    CurrentOption = {locationNames[1]},
    Flag = "RadarFarmDropdown",
    Callback = function(option)
        local choice = option[1] -- ‚úÖ fix: Dropdown gibt Tabelle zur√ºck
        OrionLib:MakeNotification({
            Title = "Auswahl",
            Content = "üìç "..choice.." ausgew√§hlt!",
            Duration = 2
        })
    end
})

-- üìå Teleport Button
Tab7:AddButton({
    Name = "üîµ Teleport",
    Callback = function()
        local choice = OrionLib.Flags["RadarFarmDropdown"].Value -- üéâ FIX
        if not choice or not Locations[choice] then
            return OrionLib:MakeNotification({
                Title = "Fehler",
                Content = "Bitte zuerst einen Ort ausw√§hlen!",
                Duration = 3
            })
        end

        tweenTo(Locations[choice])
        OrionLib:MakeNotification({
            Title = "Teleport",
            Content = "üöóüí® Teleport zu "..choice.." gestartet!",
            Duration = 3
        })
    end
})

Tab7:AddSection({
	Name = "Poice-Settings"
})


-- ‚ö° Auto Taser (Rayfield Edition)
Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
RunService = game:GetService("RunService")

LocalPlayer = Players.LocalPlayer

-- üì° Einstellungen
local REMOTE_FOLDER = "MW5"
local REMOTE_ID = "05e1f5a3-0391-4ea8-a2ea-71839b2417d7"
local AUTO_TASER_INTERVAL = 0.5
local MAX_TASE_RANGE = 80

-- üß† Variablen
autoEnabled = false
lastTase = 0

-- üß© Position des Tasers finden
function getTaserPosition()
	local char = LocalPlayer.Character
	if not char then return nil, nil end

	local taser = char:FindFirstChild("Taser")
	if taser then
		local handle = taser:FindFirstChild("Handle")
		if handle and handle:IsA("BasePart") then
			return handle.Position, taser
		end
	end

	local hrp = char:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		return hrp.Position, nil
	end

	return nil, nil
end

-- üéØ N√§chsten Gegner finden
function findNearestEnemy(maxRange)
	local pos = getTaserPosition()
	if not pos then return nil end
	local taserPos = pos
	local nearestPlayer, nearestDist

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Team ~= LocalPlayer.Team then
			local char = plr.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			if hrp then
				local dist = (hrp.Position - taserPos).Magnitude
				if dist <= maxRange and (not nearestDist or dist < nearestDist) then
					nearestDist = dist
					nearestPlayer = plr
				end
			end
		end
	end
	return nearestPlayer
end

-- ‚ö° Gegner tasern
function fireTaserAtTarget()
	local taserPos, taserObj = getTaserPosition()
	if not taserPos then return end

	local target = findNearestEnemy(MAX_TASE_RANGE)
	if not target or not target.Character then return end

	local hrp = target.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local aimPos = hrp.Position
	local dir = aimPos - taserPos
	dir = dir.Magnitude == 0 and Vector3.zero or dir.Unit

	local folder = ReplicatedStorage:FindFirstChild(REMOTE_FOLDER)
	if not folder then return end

	local remote = folder:FindFirstChild(REMOTE_ID)
	if not remote then return end

	local args = { taserObj, aimPos, dir }

	pcall(function()
		if remote:IsA("RemoteEvent") then
			remote:FireServer(unpack(args))
		elseif remote:IsA("RemoteFunction") then
			remote:InvokeServer(unpack(args))
		end
	end)
end

-- üîÅ Automatischer Loop
RunService.RenderStepped:Connect(function()
	if autoEnabled and tick() - lastTase >= AUTO_TASER_INTERVAL then
		fireTaserAtTarget()
		lastTase = tick()
	end
end)

-- üü¢ Rayfield-Toggle (kein Callback-Error mehr)
Tab7:AddToggle({
	Name = "üîµ Auto Taser",
	CurrentValue = false,
	Flag = "AutoTaser",
	Callback = function(Value)
		autoEnabled = Value

		if Value then
			OrionLib:MakeNotification({
				Title = "Auto Taser aktiviert ‚ö°",
				Content = "Automatisches Tasern l√§uft.",
				Duration = 3
			})
		else
			OrionLib:MakeNotification({
				Title = "Auto Taser gestoppt ‚õî",
				Content = "Automatisches Tasern beendet.",
				Duration = 3
			})
		end
	end
})

Tab7:AddSection({
	Name = "üîµ Anti-Police"
})

antiTaserActive = false
antiTaserConnection = nil

-- Funktion zum Aktivieren oder Deaktivieren
function toggleAntiTaser(state)
	antiTaserActive = state

	if antiTaserActive then
		-- Sofort sicherstellen, dass "Tased" auf false ist
		local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
		char:SetAttribute("Tased", false)

		-- Verbindung setzen
		antiTaserConnection = char:GetAttributeChangedSignal("Tased"):Connect(function()
			if antiTaserActive then
				char:SetAttribute("Tased", false)
			end
		end)
	else
		if antiTaserConnection then
			antiTaserConnection:Disconnect()
			antiTaserConnection = nil
		end
	end
end

-- Rayfield Toggle
Tab7:AddToggle({
	Name = "üîµ Anti-Taser",
	CurrentValue = false,
	Callback = function(state)
		toggleAntiTaser(state)
	end
})


AntiArrestToggle = false

Tab7:AddToggle({
	Name = "üîµ Anti Arrest",
	CurrentValue = false,
	Callback = function(state)
		AntiArrestToggle = state
	end
})

-- Sicherheitssystem
task.spawn(function()
	local Players = game:GetService("Players")
	local player = Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local rootPart = character:WaitForChild("HumanoidRootPart")
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

	-- Position sicher?
	local function isPositionSafe(position)
		local region = Region3.new(position - Vector3.new(1,1,1), position + Vector3.new(1,1,1))
		local parts = workspace:FindPartsInRegion3(region, character, 100)
		for _, part in ipairs(parts) do
			if part.CanCollide then return false end
		end
		return true
	end

	-- Finde sichere Fluchtposition
	local function findSafeTeleportPosition(fromPosition, awayFromPosition)
		local directions = {
			Vector3.new(1, 0, 0),
			Vector3.new(-1, 0, 0),
			Vector3.new(0, 0, 1),
			Vector3.new(0, 0, -1),
			Vector3.new(0, 1, 0),
			Vector3.new(0, -1, 0),
			Vector3.new(1, 1, 0).Unit,
			Vector3.new(-1, 1, 0).Unit,
			Vector3.new(0, 1, 1).Unit,
			Vector3.new(0, 1, -1).Unit
		}
		table.insert(directions, 1, (fromPosition - awayFromPosition).Unit)

		for _, dir in ipairs(directions) do
			local testPosition = fromPosition + (dir * 8)
			local ray = workspace:Raycast(fromPosition, dir * 8, raycastParams)
			if not ray or (ray.Instance and not ray.Instance.CanCollide) then
				if isPositionSafe(testPosition) then
					return testPosition
				end
			end
		end
		return fromPosition + Vector3.new(0, 5, 0)
	end

	-- Haupt-Loop
	while true do
		task.wait(0.2)
		if AntiArrestToggle then
			character = player.Character or player.CharacterAdded:Wait()
			rootPart = character:FindFirstChild("HumanoidRootPart")
			raycastParams.FilterDescendantsInstances = {character}

			if rootPart and not character.Humanoid.Sit then
				for _, otherPlayer in ipairs(Players:GetPlayers()) do
					if otherPlayer ~= player and otherPlayer.Team and otherPlayer.Team.Name:lower() == "police" then
						local otherRoot = otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart")
						if otherRoot then
							local distance = (otherRoot.Position - rootPart.Position).Magnitude
							if distance <= 10 then
								local safePos = findSafeTeleportPosition(rootPart.Position, otherRoot.Position)
								rootPart.CFrame = CFrame.new(safePos)

								game.StarterGui:SetCore("SendNotification", {
									Title = "Anti-Arrest",
									Text = "Zu nah an Polizei - sichere Position gew√§hlt!",
									Duration = 2
								})
							end
						end
					end
				end
			end
		end
	end
end)



Tab7:AddToggle({
    Name = "üîµ Anti-fall-damage",
    Flag = "Toggle3",
    CurrentValue = false,
    Callback = function(enabled)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local player = Players.LocalPlayer
        local connection

        local function startAntiFall()
            if connection then connection:Disconnect() end
            connection = RunService.RenderStepped:Connect(function()
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if hrp and humanoid then
                    if hrp.Velocity.Y < -80 then
                        hrp.Velocity = Vector3.new(hrp.Velocity.X, -10, hrp.Velocity.Z)
                    end
                end
            end)
        end

        if enabled then
            startAntiFall()
            player.CharacterAdded:Connect(function()
                wait(1)
                if enabled then
                    startAntiFall()
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end,
})

Tab7:AddToggle({
    Name = "üîµ God Mode",
    CurrentValue = false,
    Flag = "Toggle2",
    SectionParent = OtherSection,
    Callback = function(Value)
        getgenv().godMode = Value
        while true do
            if not getgenv().godMode then return end

            game.Players.LocalPlayer.Character.Humanoid.Health = 100
            task.wait()
        end
    end,
})

Tab8 = Window:MakeTab({
	Name = "Server | ü§ì",
	Icon = "",
	PremiumOnly = false
})

Tab8:AddSection({
	Name = "Server-Settings"
})

Tab8:AddButton({
    Name = "üü° Rejoin",
    Callback = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
    end,
})

Tab8:AddButton({
    Name = "üü° Leave",
    Callback = function()
        game:GetService("Players").LocalPlayer:Kick("You have left the game.")
    end,
})

function RejoinToNewLobby()
	local HttpService = game:GetService("HttpService")
	local TeleportService = game:GetService("TeleportService")
	local PlaceId = game.PlaceId
	local Player = game.Players.LocalPlayer

	local success, response = pcall(function()
		return HttpService:JSONDecode(
			game:HttpGet("https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100")
		)
	end)

	if success and response and response.data then
		for _, server in pairs(response.data) do
			if server.playing < server.maxPlayers and server.id ~= game.JobId then
				TeleportService:TeleportToPlaceInstance(PlaceId, server.id, Player)
				return
			end
		end
	end

	OrionLib:MakeNotification({
		Title = "‚ö†Ô∏è Fehler",
		Content = "Keine andere Lobby gefunden. Bitte erneut versuchen.",
		Duration = 4
	})
end

-- üîò Button zum Wechseln der Lobby
Tab8:AddButton({
	Name = "üü° Server-Hop",
	Callback = function()
		RejoinToNewLobby()
	end
})

Tab8:AddSection({
	Name = "üü° More-FPS"
})


-- Funktion
function toggleXRay(enabled)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") 
        and obj.Transparency < 1 
        and not obj:IsDescendantOf(game.Players.LocalPlayer.Character) then
            obj.LocalTransparencyModifier = enabled and 0.8 or 0
        end
    end
end

-- Toggle in Rayfield
Tab8:AddToggle({
    Name = "üü° XRay",
    CurrentValue = false,
    Flag = "XRayToggle", 
    Callback = function(Value)
        toggleXRay(Value)
    end,
})


-- NightVision Funktion
function enableNightVision(val)
    local lighting = game:GetService("Lighting")
    local existing = lighting:FindFirstChild("NightVision")
    if val and not existing then
        local cc = Instance.new("ColorCorrectionEffect", lighting)
        cc.Name = "NightVision"
        cc.TintColor = Color3.fromRGB(128, 255, 128)
        cc.Contrast = 0.1
        cc.Saturation = 1
    elseif not val and existing then
        existing:Destroy()
    end
end

-- NightVision Toggle
Tab8:AddToggle({
    Name = "üü° Night Vision",
    CurrentValue = false,
    Flag = "NightVisionToggle", 
    Callback = function(Value)
        enableNightVision(Value)
    end,
})


-- Dein Fullbright Code
fullbrightOn = false
function enableFullbright(val)
    fullbrightOn = val
    local lighting = game:GetService("Lighting")
    if val then
        lighting.Ambient = Color3.new(1,1,1)
        lighting.OutdoorAmbient = Color3.new(1,1,1)
        lighting.Brightness = 3
        lighting.FogEnd = 1000000
    else
        lighting.Ambient = Color3.fromRGB(112, 112, 112)
        lighting.OutdoorAmbient = Color3.fromRGB(112, 112, 112)
        lighting.Brightness = 1
        lighting.FogEnd = 1000
    end
end

-- Toggle erstellen
Tab8:AddToggle({
    Name = "üü° Fullbright",
    CurrentValue = false,
    Flag = "FullbrightToggle", 
    Callback = function(Value)
        enableFullbright(Value)
    end,
})

Tab8:AddButton({
    Name = "üü° FPS-Booster",
    Callback = function()
        -- Nur globale Effekte und Schatten deaktivieren, aber KEINE Texturen, KEIN Sky, KEINE H√§user/Objekte entfernen!
        game.Lighting.GlobalShadows = false
        game.Lighting.FogEnd = 1000
        game.Lighting.Brightness = 1
        game.Lighting.OutdoorAmbient = Color3.new(1,1,1)
        -- Terrain Wasser optimieren (aber keine H√§user oder Terrain l√∂schen!)
        if workspace:FindFirstChildOfClass("Terrain") then
            local terrain = workspace:FindFirstChildOfClass("Terrain")
            terrain.WaterWaveSize = 0
            terrain.WaterWaveSpeed = 0
            terrain.WaterReflectance = 0
            terrain.WaterTransparency = 1
        end
        -- Nur GUI-Effekte entfernen
        for _, v in pairs(game:GetService("StarterGui"):GetDescendants()) do
            if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("BloomEffect") or v:IsA("DepthOfFieldEffect") then
                v.Enabled = false
            end
        end
        -- Renderqualit√§t runtersetzen
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    end,
})

Tab8:AddButton({
    Name = "üü° Remove-Sky",
    Callback = function()
        game.Lighting.Sky:Destroy() -- Remove the sky object
    end,
})


Tab9 = Window:MakeTab({
	Name = "Info | üì¢",
	Icon = "",
	PremiumOnly = false
})

Tab9:AddSection({
	Name = "Infos"
})

Tab9:AddLabel("Authors: Trixo and Zeroo", 4483362458, Color3.fromRGB(255, 255, 255), false) -- Title, Icon, Color, IgnoreTheme
Tab9:AddLabel("Version: 2.0", 4483362458, Color3.fromRGB(255, 255, 255), false) -- Title, Icon, Color, IgnoreTheme
Tab9:AddButton({
	Name = "Trixo Discord",
	Callback = function()
		setclipboard("https://discord.gg/fqzdkQrvxy")
		OrionLib:MakeNotification({
			Title = "Discord-Link kopiert!",
			Content = "F√ºge ihn in deinen Browser ein oder Discord.",
			Duration = 5
		})
	end
})

Tab9:AddButton({
	Name = "Trixo YouTube",
	Callback = function()
		setclipboard("https://youtube.com/@toxo-zp2kx?si=oJTzPIXp2XncsJfG")
		OrionLib:MakeNotification({
			Title = "YouTube-Link kopiert!",
			Content = "F√ºge ihn in deinen Browser ein oder Discord.",
			Duration = 5
		})
	end
})

Tab9:AddButton({
	Name = "Trixo TikTok",
	Callback = function()
		setclipboard("https://www.tiktok.com/@trixo_55?_r=1&_t=ZS-923SrfVR6iG")
		OrionLib:MakeNotification({
			Title = "TikTok-Link kopiert!",
			Content = "F√ºge ihn in deinen Browser ein oder Discord.",
			Duration = 5
		})
	end
})